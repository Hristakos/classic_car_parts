require 'cloudinary'
require 'cloudinary/uploader'
require 'cloudinary/utils'

def listing_timestamp_to_display(timestamp)
    day = DateTime.parse(timestamp).day
    month = DateTime.parse(timestamp).month
    year = DateTime.parse(timestamp).year
    "#{day}/#{month}/#{year}"
end

def upload_listing_image(file_path,user_id)
    uploads = {}
    # public_id for the uploaded image is generated by Cloudinary's service.
    uploads[:cover_image] = Cloudinary::Uploader.upload "#{file_path}",
    :tags => "basic_sample",
    :public_id => "cover_#{user_id}"

    uploads[:cover_image]['url']
        # uploads.each_value.with_index do |upload, index|
        #      puts "> Upload \##{index+1}:"
        #      puts "  Public ID: #{upload['public_id']}"
        #      puts "  URL: #{upload['url']}"
        #  end
end

def run_sql(sql,params)
    conn = PG.connect(ENV['DATABASE_URL'] || {dbname: 'classic_car_parts'})
    records = conn.exec_params(sql,params)
    conn.close
    records
end

def create_listing(headline, description, user_id, suburb, post_date,price, img_path)
    img_url = upload_listing_image(img_path, user_id)
    run_sql("insert into listings(headline,description,user_id,suburb,post_date,price,img_url)values ($1, $2, $3, $4, $5,$6,$7);",[headline, description,user_id,suburb,post_date,price,img_url])
end

def all_listings()
    listings = run_sql("select * from listings order by post_date desc;",[])
    listings
end

def all_listings_for_user(user_id)
    listings = run_sql("select * from listings where user_id = $1 order by post_date desc;",[user_id])
    listings
end

def find_a_listing_by_id(id)
    run_sql("select * from listings where id = $1;",[id])[0]
end

def find_a_user_listing_by_ids(id, user_id)
    records = run_sql("select * from listings where id = $1 and user_id = $2;",[id, user_id])
    if records.count == 0
        return nil
    else
        return records[0]
    end
end

def update_listing(id, headline, description,suburb,price)
    run_sql("update listings set headline = $1, description = $2,suburb = $3, price = $4 where id = $5;",[headline,description,suburb,price,id])
end

def delete_listing(id)
    run_sql("delete from listings where id = $1;",[id])
end

def all_listings_by_query(search,sort_query)
    search_string = "%#{search}%"  
    listings = run_sql("select * from listings where headline like $1 order by #{sort_query};",[search_string])
    listings
end

def all_listings_for_user(user_id)
    listings = run_sql("select * from listings where user_id = $1;",[user_id])
    listings
end
def all_listings_for_user_by_query(user_id,search,sort_query)
    search_string = "%#{search}%"  
    listings = run_sql("select * from listings where user_id = $1 and headline like $2 order by #{sort_query};",[user_id,search_string])
    listings
end

def all_listings_by_suburb(search,suburb_order)
    search_string = "%#{search}%"
    suburb_string = "suburb #{suburb_order}"
    listings = run_sql("select * from listings where headline like $1 order by #{suburb_string};",[search_string])
    listings
end

def add_message_to_listing(listing_id, message)

    run_sql( "update listings set messages =  array_append(messages, $1) where id = $2;",[message,listing_id])

end

def retrieve_messages_for_listing(listing_id)
    messages = run_sql('select messages from listings where id = $1;',[listing_id])
    if messages[0]["messages"]
       return messages[0]["messages"].gsub(/[{}"]/,"").chomp().split(",")
    end

    nil
end

def potential_buyer_input_validate(name, best_contact)
    msg = nil
    if name.size < 3
       msg = "name must be at least 3 characters long"
    elsif best_contact.size < 10 
        msg = "best contact must be at least 10 characters long"
    end
    
    if msg 
        return error = {name: name,
                      best_contact: best_contact,
                      message: msg
                    }       
    else
        return nil
    end
end

